{-# LANGUAGE GADTs, RankNTypes, ConstraintKinds, ImpredicativeTypes, ScopedTypeVariables, DeriveDataTypeable, DeriveGeneric #-}

import Control.Monad as Monad
import Data.Functor.Identity(Identity(Identity), runIdentity)
import Data.Maybe as Maybe
import Data.List as List
import Data.Map as Map
import Data.Set as Set
import Data.Ord
import Data.ByteString

import Data.Dynamic as Dynamic

import Data.Word (Word32, Word64)
-- hackage 'memory'
import Data.ByteArray.Hash (sipHash, SipKey(SipKey), SipHash(SipHash))
-- hackage 'cereal'
import Data.Serialize (Serialize, encode)
import GHC.Generics (Generic)

import Text.Printf

-- A Time Steward is a tuple of a time-type, an arbitrary tuple of entity field types, and an arbitrary tuple of predictors




data UInt128 = UInt128 {-#UNPACK#-}!Word64 {-#UNPACK#-}!Word64
  deriving (Eq, Ord, Generic)
instance Serialize UInt128
-- allow some numeric literals but any other Num operation is an error
-- (we don't need to bother implementing the rest)
-- TODO implement them by wrapping toInteger/fromIn
instance Num UInt128 where
  fromInteger n | n >= 0 && n <= 0xffffffffffffffffffffffffffffffff =
    case n `divMod` 0x10000000000000000 of
      (hi, lo) -> UInt128 (fromInteger hi) (fromInteger lo)
  fromInteger _ = error "UInt128: fromInteger: out of range"
  a + b = fromInteger (toInteger a + toInteger b)
  a - b = fromInteger (toInteger a - toInteger b)
  a * b = fromInteger (toInteger a * toInteger b)
  abs = id
  signum = fromInteger . signum . toInteger
  negate = fromInteger . negate . toInteger
instance Real UInt128 where
  toRational i = fromInteger (toInteger i)
instance Enum UInt128 where
  succ = fromInteger . succ . toInteger
  pred = fromInteger . pred . toInteger
  toEnum = fromIntegral
  fromEnum = fromIntegral
  enumFrom = List.map fromInteger . enumFrom . toInteger
  enumFromThen a b = List.map fromInteger (enumFromThen (toInteger a) (toInteger b))
  enumFromTo a b = List.map fromInteger (enumFromTo (toInteger a) (toInteger b))
  enumFromThenTo a b c = List.map fromInteger (enumFromThenTo (toInteger a) (toInteger b) (toInteger c))
instance Integral UInt128 where
  toInteger (UInt128 hi lo) = toInteger hi * 0x10000000000000000 + toInteger lo
  a `quot` b = fromInteger (toInteger a `quot` toInteger b)
  a `rem` b = fromInteger (toInteger a `rem` toInteger b)
  a `quotRem` b = case (toInteger a `quotRem` toInteger b) of (c, d) -> (fromInteger c, fromInteger d)
  a `div` b = fromInteger (toInteger a `div` toInteger b)
  a `mod` b = fromInteger (toInteger a `mod` toInteger b)
  a `divMod` b = case (toInteger a `divMod` toInteger b) of (c, d) -> (fromInteger c, fromInteger d)

instance Show UInt128 where
  --show (UInt128 hi lo) = show (toInteger hi * 0x10000000000000000 + toInteger lo)
  show i = printf "0x%016x" (toInteger i)

-- generated by crypto random number generator, although
-- they maybe don't even have to be random given they are
-- not secret
sipkey1, sipkey2 :: SipKey
sipkey1 = SipKey 0xb82a9426fd1a574f 0x9d9d5b703dcb1bcc
sipkey2 = SipKey 0x03e0d6037ff980a4 0x65b790a0825b83bd
collisionResistantHash :: (Serialize a) => a -> UInt128
collisionResistantHash a = let
  b :: ByteString
  b = encode a
  SipHash h1 = sipHash sipkey1 b
  SipHash h2 = sipHash sipkey2 b
  in UInt128 h1 h2

data EntityId = EntityId UInt128
  deriving (Eq, Ord, Generic)
instance Serialize EntityId
instance Show EntityId where
  show (EntityId n) = "entity:" ++ show n

--data Distinguisher = Distinguisher UInt128 -- normally a hash and therefore statistically never zero or maximum, which matters for beginningOfTime being clear
type Distinguisher = UInt128

type NumberOfTimesTheComputerCanDoSomething = Word64
data ExtendedTime = ExtendedTime {
  etBaseTime :: BaseTime,
  etIterationNumber :: NumberOfTimesTheComputerCanDoSomething,
  etDistinguisher :: Distinguisher
  }
  deriving (Eq, Ord, Generic)
instance Serialize ExtendedTime
instance {-(Show BaseTime) =>-} Show ExtendedTime where
  show et = show (etBaseTime et) ++ "::" ++ show (etIterationNumber et) ++ "::" ++ show (etDistinguisher et)

--class (Serializable s {-which implies hashable-}) => CanBeAnEntityFieldType where {}
type CanBeAnEntityFieldType = Serialize --a class

class (Typeable f, Serialize f) => FieldType f where
  defaultFieldValue :: f

--type ValueRetriever m = (forall f. (FieldType f) => EntityId -> Proxy f -> m f)
--type EntityValueTuple = (forall f. (FieldType f) => (EntityId, Proxy f, f))

type ValueRetriever m = (forall f. (FieldType f) => EntityId -> m f)

-- the Dynamic must be one of the entity field types...
type EntityValueTuple = (EntityId, Dynamic)


-- is there some way we can make a visualizer of entanglement?


-- It's common for predictors to return one thing.
-- It would be fine if they return a maximum of one thing, because you never would get to the second thing unless the first thing is in the past.
-- Predictors usually get the time from the data of one/some of the entities they access. For example if you have a
-- bubble wand that emits bubbles every second then the wand could store the time at which it last emitted a bubble.
-- Predictors maybe have to return nothing for entities with all default/null values.
--type Predictor = forall m. (Monad m) => EntityId -> (forall f. (FieldType f) => EntityId -> Proxy f -> m f) -> m [(Time, Event)]
data Predictor where
  Predictor :: (forall m. (Monad m) => ValueRetriever m -> EntityId -> m (Maybe (BaseTime, Event))) -> Predictor
  --Predictor :: (forall m. (Monad m) => ValueRetriever m -> EntityId -> m [(Time, Event)]) -> Predictor

--type Event = forall m. (Monad m) => ValueRetriever m -> m [EntityValueTuple]
data Event where
  Event :: (forall m. (Monad m) => ValueRetriever m -> m [EntityValueTuple]) -> Event


--An Inefficient Flat Time Steward Instance is (a time "now", x a set of non-default entity field states ((entity-id x field-type) -> value : field-type), x a collection of fiat event (Event, Time, distinguisher), x a function from a time >= "now" to a Inefficient Flat Time Steward Instance)  Also a way to alter the collection of fiat events, though that might be implied by it being a data structuer

--data EntityFieldState where
--  EntityFieldState :: (CanBeAnEntityFieldType f) => EntityId -> f -> EntityFieldState

data InefficientFlatTimeStewardInstance = InefficientFlatTimeStewardInstance {
  iftsiNow :: ExtendedTime, --BaseTime, -- All events before and during[?] this time have been executed
  iftsiEntityFieldStates :: Map EntityId [Dynamic], --inefficient
  -- iftsiFiatEvents may contain events in the past, but they don't do anything,
  -- so it's the same whether they are present or not.
  -- The key is like an ExtendedTime where the second part (iteration number) is implicitly zero.
  -- TODO make sure the distinguisher is a hash
  --iftsiFiatEvents = Map (BaseTime, Distinguisher) Event -- may not be needed to order them this much but it is ok to unique them and order like this
  iftsiFiatEvents :: Map ExtendedTime Event,
  -- this is supposed to be immutable:
  iftsiPredictors :: [Predictor]
  }
--  deriving (Generic)
--instance Serialize InefficientFlatTimeStewardInstance

updateEntityFields :: [EntityValueTuple] -> Map EntityId [Dynamic] -> Map EntityId [Dynamic]
updateEntityFields tups m =
  let
  changes = Map.fromListWith (++) (List.map (\ (k,v) -> (k,[v])) tups)
  combine old new = let
    newTypes = Set.fromList (List.map dynTypeRep new)
    in
    new ++ List.filter (\d -> Set.notMember (dynTypeRep d) newTypes) old
  in
  Map.unionWith combine m changes

createExtendedTime :: (Serialize d) => BaseTime -> d -> ExtendedTime
createExtendedTime t d = ExtendedTime t 0 (collisionResistantHash ("createExtendedTime", d))


-- this is the inefficient time steward so we don't need
-- to store which things were accessed by predictors
valueRetriever :: forall f. (FieldType f) => InefficientFlatTimeStewardInstance -> EntityId -> Identity f
valueRetriever iftsi entityId = Identity $ fromMaybe (defaultFieldValue :: f) $ do{-Maybe monad-}
    fields <- Map.lookup entityId (iftsiEntityFieldStates iftsi)
    listToMaybe (Maybe.mapMaybe fromDynamic fields)

nextEvent :: InefficientFlatTimeStewardInstance -> Maybe (ExtendedTime, Event)
nextEvent iftsi = let
  now = iftsiNow iftsi
  firstFiatEvent :: Maybe (ExtendedTime, Event)
  firstFiatEvent = Map.lookupGT now (iftsiFiatEvents iftsi)
    --do{-Maybe monad-}
    --((baseTime, distinguisher), event) <- (Map.lookupGT now (iftsiFiatEvents iftsi)
    --return (ExtendedTime baseTime 0 distinguisher, event)
  valueRetrieverNow :: forall f. (FieldType f) => EntityId -> Identity f
  valueRetrieverNow = valueRetriever iftsi
  -- here's the inefficient part
  predictedEvents :: [(ExtendedTime, Event)]
  predictedEvents = do{-List monad-}
    (entityId, _fields) <- Map.toList (iftsiEntityFieldStates iftsi)
    -- field <- fields
    (predictorNum, predictor) <- List.zip [(1::Word32) ..] (iftsiPredictors iftsi)
    let Predictor p = predictor
    (eventBaseTime, event) <- maybeToList (runIdentity (p valueRetrieverNow entityId))
    let eventTimeDistinguisher = collisionResistantHash (predictorNum, entityId)
    eventTimeIterationNumber <- case compare eventBaseTime (etBaseTime now) of
      LT -> []
      EQ -> -- eli thinks it's important to place it at the soonest possible iteration, rather than any future iteration in this base time?
            if eventTimeDistinguisher > etDistinguisher now
            then [etIterationNumber now]
            else [etIterationNumber now + 1]
      GT -> [0]
    let eventExtendedTime = ExtendedTime eventBaseTime eventTimeIterationNumber eventTimeDistinguisher
    return (eventExtendedTime, event)
  events = maybeToList firstFiatEvent ++ predictedEvents
  -- sortOn not defined in older GHC
  timeOrderedEvents = sortBy (comparing fst) events
  in
  listToMaybe timeOrderedEvents

executeEvent :: ExtendedTime -> Event -> InefficientFlatTimeStewardInstance -> InefficientFlatTimeStewardInstance
-- unchecked precondition: the event is the next event
executeEvent eventTime (Event event) iftsi = let
  --now = iftsiNow iftsi
  valueRetrieverNow :: forall f. (FieldType f) => EntityId -> Identity f
  valueRetrieverNow = valueRetriever iftsi
  changedEntityFields = runIdentity (event valueRetrieverNow)
  in
  iftsi {
    iftsiNow = eventTime,
    iftsiEntityFieldStates = updateEntityFields changedEntityFields (iftsiEntityFieldStates iftsi)
  }




beginningOfMoment :: BaseTime -> ExtendedTime
beginningOfMoment t = ExtendedTime t 0 0

moveIFTSIToFutureTime :: ExtendedTime -> InefficientFlatTimeStewardInstance -> InefficientFlatTimeStewardInstance
moveIFTSIToFutureTime futureT iftsi
  | futureT >= iftsiNow iftsi =
    case nextEvent iftsi of
      Nothing -> iftsi { iftsiNow = futureT }
      Just (eventTime, event)
        | eventTime > futureT -> iftsi { iftsiNow = futureT }
        | otherwise ->
          let iftsi' = executeEvent eventTime event iftsi
          in moveIFTSIToFutureTime futureT iftsi'
  | otherwise = error "not defined for past times"


--data Buggy = Buggy | Okay
--testPredictorForObviousBugs :: Predictor -> Buggy
--testPredictorForObviousBugs (Predictor p) =






-- For now so the haskell compiles with less work, i'll
type BaseTime = Integer
--type EntityFieldTypes = ()
--type Predictors = ()

newtype Location = Location (Int, Int)
  deriving (Eq, Ord, Typeable, Generic)
instance Serialize Location
instance FieldType Location where
  defaultFieldValue = Location (-1,-1)

newtype LastMove = LastMove BaseTime
  deriving (Eq, Ord, Typeable, Generic)
instance Serialize LastMove
instance FieldType LastMove where
  defaultFieldValue = LastMove 0

predictor1, wander :: forall m. (Monad m) => ValueRetriever m -> EntityId -> m (Maybe (BaseTime, Event))
predictor1 _valueRetriever _entityId = return Nothing

wander valueRetriever entityId = do
  Location (loc@(x,y)) <- valueRetriever entityId
  if (Location loc == defaultFieldValue)
    then return Nothing
    else do
      LastMove t <- valueRetriever entityId
      let nextMoveTime = t + 3
      --return $ Just $ (,) nextMoveTime $ \valueRetriever' -> do
      return (Just ((,) nextMoveTime (Event (\valueRetriever' -> do
        -- TODO: maybe retrieve the location here rather than
        -- when the event is predicted?
        return [
            (entityId, toDyn $ LastMove nextMoveTime),
            (entityId, toDyn $ Location (x, (y + 1) `mod` 7))
          ]))))


  --return (Just (t + 3, \valueRetriever' -> do
  

predictors :: [Predictor]
predictors = [Predictor predictor1, Predictor wander]

-- TODO should the user get a collisionResistantHash function
-- with different SipKey so that they don't accidentally make the same
-- hash as an internally derived thing? hmm

initialWorld :: InefficientFlatTimeStewardInstance
initialWorld = InefficientFlatTimeStewardInstance {
  iftsiNow = beginningOfMoment 2,
  -- Haskell shares with C++ the lack of a nice literal syntax for maps
  iftsiEntityFieldStates = Map.fromList [
    (EntityId $ collisionResistantHash "your guy", [toDyn $ Location (3,3), toDyn $ LastMove 1])
    ],
  iftsiFiatEvents = Map.fromList [],
  iftsiPredictors = predictors
  }

showWorld :: InefficientFlatTimeStewardInstance -> String
showWorld iftsi = let
  places :: Map Location ()
  places = Map.fromList . List.map (\loc -> (loc, ())) .
             Maybe.mapMaybe Dynamic.fromDynamic .
             List.concat . Map.elems $ (iftsiEntityFieldStates iftsi)
  -- Not [[Char]] because some single-width grapheme clusters are
  -- multiple codepoints
  board :: [[String]]
  board = flip List.map [1..7] $ \y ->
    flip List.map [1..7] $ \x ->
      case Map.lookup (Location (x,y)) places of
        Nothing -> "·"
        Just _ -> "é"
  boardString :: String
  boardString = List.concat . List.intersperse "\n" . List.map List.concat $ board
  in
  "Time: " ++ show (iftsiNow iftsi) ++ "\n" ++ boardString ++ "\n"

main = do
  Prelude.putStrLn $ showWorld initialWorld
  forM_ [3..15] $ \t ->
    Prelude.putStrLn $ showWorld $ moveIFTSIToFutureTime (beginningOfMoment t) $ initialWorld


