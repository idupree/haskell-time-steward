{-# LANGUAGE GADTs, RankNTypes, ConstraintKinds, ImpredicativeTypes, ScopedTypeVariables, DeriveGeneric #-}

--import Control.Monad
import Data.Functor.Identity(Identity(Identity), runIdentity)
import Data.Maybe as Maybe
import Data.List as List
import Data.Map as Map
import Data.Set as Set
import Data.Ord
import Data.ByteString

import Data.Dynamic

import Data.Word (Word32, Word64)
-- hackage 'memory'
import Data.ByteArray.Hash (sipHash, SipKey(SipKey), SipHash(SipHash))
-- hackage 'cereal'
import Data.Serialize (Serialize, encode)
import GHC.Generics (Generic)

-- A Time Steward is a tuple of a time-type, an arbitrary tuple of entity field types, and an arbitrary tuple of predictors

-- For now so the haskell compiles with less work, i'll
type BaseTime = Integer
type EntityFieldTypes = ()
--type Predictors = ()
predictor1 :: forall m. (Monad m) => ValueRetriever m -> EntityId -> m (Maybe (BaseTime, Event))
predictor1 _entityId _valueRetriever = return Nothing
predictors :: [Predictor]
predictors = [Predictor predictor1]



data UInt128 = UInt128 {-#UNPACK#-}!Word64 {-#UNPACK#-}!Word64
  deriving (Eq, Ord, Generic)
instance Serialize UInt128
-- allow some numeric literals but any other Num operation is an error
-- (we don't need to bother implementing the rest)
instance Num UInt128 where
  fromInteger n | n >= 0 && n <= 0xffffffffffffffff = UInt128 0 (fromInteger n)
  fromInteger _ = error "UInt128: fromInteger: unimplemented"
  (+) = error "UInt128: +: unimplemented"
  (-) = error "UInt128: -: unimplemented"
  (*) = error "UInt128: *: unimplemented"
  abs = error "UInt128: abs: unimplemented"
  signum = error "UInt128: signum: unimplemented"
  negate = error "UInt128: negate: unimplemented"

-- generated by crypto random number generator, although
-- they maybe don't even have to be random given they are
-- not secret
sipkey1, sipkey2 :: SipKey
sipkey1 = SipKey 0xb82a9426fd1a574f 0x9d9d5b703dcb1bcc
sipkey2 = SipKey 0x03e0d6037ff980a4 0x65b790a0825b83bd
collisionResistantHash :: (Serialize a) => a -> UInt128
collisionResistantHash a = let
  b :: ByteString
  b = encode a
  SipHash h1 = sipHash sipkey1 b
  SipHash h2 = sipHash sipkey2 b
  in UInt128 h1 h2

data EntityId = EntityId UInt128
  deriving (Eq, Ord, Generic)
instance Serialize EntityId

--data Distinguisher = Distinguisher UInt128 -- normally a hash and therefore statistically never zero or maximum, which matters for beginningOfTime being clear
type Distinguisher = UInt128

type NumberOfTimesTheComputerCanDoSomething = Word64
data ExtendedTime = ExtendedTime {
  etBaseTime :: BaseTime,
  etIterationNumber :: NumberOfTimesTheComputerCanDoSomething,
  etDistinguisher :: Distinguisher
  }
  deriving (Eq, Ord, Generic)
instance Serialize ExtendedTime

--class (Serializable s {-which implies hashable-}) => CanBeAnEntityFieldType where {}
type CanBeAnEntityFieldType = Serialize --a class

class (Typeable f, Serialize f) => FieldType f where
  defaultFieldValue :: f

--type ValueRetriever m = (forall f. (FieldType f) => EntityId -> Proxy f -> m f)
--type EntityValueTuple = (forall f. (FieldType f) => (EntityId, Proxy f, f))

type ValueRetriever m = (forall f. (FieldType f) => EntityId -> m f)

-- the Dynamic must be one of the entity field types...
type EntityValueTuple = (EntityId, Dynamic)


-- is there some way we can make a visualizer of entanglement?


-- It's common for predictors to return one thing.
-- It would be fine if they return a maximum of one thing, because you never would get to the second thing unless the first thing is in the past.
-- Predictors usually get the time from the data of one/some of the entities they access. For example if you have a
-- bubble wand that emits bubbles every second then the wand could store the time at which it last emitted a bubble.
-- Predictors maybe have to return nothing for entities with all default/null values.
--type Predictor = forall m. (Monad m) => EntityId -> (forall f. (FieldType f) => EntityId -> Proxy f -> m f) -> m [(Time, Event)]
data Predictor where
  Predictor :: (forall m. (Monad m) => ValueRetriever m -> EntityId -> m (Maybe (BaseTime, Event))) -> Predictor
  --Predictor :: (forall m. (Monad m) => ValueRetriever m -> EntityId -> m [(Time, Event)]) -> Predictor

type Event = forall m. (Monad m) => ValueRetriever m -> m [EntityValueTuple]


--An Inefficient Flat Time Steward Instance is (a time "now", x a set of non-default entity field states ((entity-id x field-type) -> value : field-type), x a collection of fiat event (Event, Time, distinguisher), x a function from a time >= "now" to a Inefficient Flat Time Steward Instance)  Also a way to alter the collection of fiat events, though that might be implied by it being a data structuer

--data EntityFieldState where
--  EntityFieldState :: (CanBeAnEntityFieldType f) => EntityId -> f -> EntityFieldState

data InefficientFlatTimeStewardInstance = InefficientFlatTimeStewardInstance {
  iftsiNow :: ExtendedTime, --BaseTime, -- All events before and during[?] this time have been executed
  iftsiEntityFieldStates :: Map EntityId [Dynamic], --inefficient
  -- iftsiFiatEvents may contain events in the past, but they don't do anything,
  -- so it's the same whether they are present or not.
  -- The key is like an ExtendedTime where the second part (iteration number) is implicitly zero.
  -- TODO make sure the distinguisher is a hash
  --iftsiFiatEvents = Map (BaseTime, Distinguisher) Event -- may not be needed to order them this much but it is ok to unique them and order like this
  iftsiFiatEvents :: Map ExtendedTime Event
  }
--  deriving (Generic)
--instance Serialize InefficientFlatTimeStewardInstance

updateEntityFields :: [EntityValueTuple] -> Map EntityId [Dynamic] -> Map EntityId [Dynamic]
updateEntityFields tups m =
  let
  changes = Map.fromListWith (++) (List.map (\ (k,v) -> (k,[v])) tups)
  combine old new = let
    newTypes = Set.fromList (List.map dynTypeRep new)
    in
    new ++ List.filter (\d -> Set.notMember (dynTypeRep d) newTypes) old
  in
  Map.unionWith combine m changes

createExtendedTime :: (Serialize d) => BaseTime -> d -> ExtendedTime
createExtendedTime t d = ExtendedTime t 0 (collisionResistantHash ("createExtendedTime", d))


-- this is the inefficient time steward so we don't need
-- to store which things were accessed by predictors
valueRetriever :: forall f. (FieldType f) => InefficientFlatTimeStewardInstance -> EntityId -> Identity f
valueRetriever iftsi entityId = Identity $ fromMaybe (defaultFieldValue :: f) $ do{-Maybe monad-}
    fields <- Map.lookup entityId (iftsiEntityFieldStates iftsi)
    listToMaybe (Maybe.mapMaybe fromDynamic fields)

nextEvent :: InefficientFlatTimeStewardInstance -> Maybe (ExtendedTime, Event)
nextEvent iftsi = let
  now = iftsiNow iftsi
  firstFiatEvent :: Maybe (ExtendedTime, Event)
  firstFiatEvent = Map.lookupGT now (iftsiFiatEvents iftsi)
    --do{-Maybe monad-}
    --((baseTime, distinguisher), event) <- (Map.lookupGT now (iftsiFiatEvents iftsi)
    --return (ExtendedTime baseTime 0 distinguisher, event)
  valueRetrieverNow :: forall f. (FieldType f) => EntityId -> Identity f
  valueRetrieverNow = valueRetriever iftsi
  -- here's the inefficient part
  predictedEvents :: [(ExtendedTime, Event)]
  predictedEvents = do{-List monad-}
    (entityId, _fields) <- Map.toList (iftsiEntityFieldStates iftsi)
    -- field <- fields
    (predictorNum, predictor) <- List.zip [(1::Word32) ..] predictors
    let Predictor p = predictor
    (eventBaseTime, event) <- maybeToList (runIdentity (p valueRetrieverNow entityId))
    let eventTimeDistinguisher = collisionResistantHash (predictorNum, entityId)
    eventTimeIterationNumber <- case compare eventBaseTime (etBaseTime now) of
      LT -> []
      EQ -> -- eli thinks it's important to place it at the soonest possible iteration, rather than any future iteration in this base time?
            if eventTimeDistinguisher > etDistinguisher now
            then [etIterationNumber now]
            else [etIterationNumber now + 1]
      GT -> [0]
    let eventExtendedTime = ExtendedTime eventBaseTime eventTimeIterationNumber eventTimeDistinguisher
    return (eventExtendedTime, event)
  events = maybeToList firstFiatEvent ++ predictedEvents
  -- sortOn not defined in older GHC
  timeOrderedEvents = sortBy (comparing fst) events
  in
  listToMaybe timeOrderedEvents

executeEvent :: ExtendedTime -> Event -> InefficientFlatTimeStewardInstance -> InefficientFlatTimeStewardInstance
-- unchecked precondition: the event is the next event
executeEvent eventTime event iftsi = let
  --now = iftsiNow iftsi
  valueRetrieverNow :: forall f. (FieldType f) => EntityId -> Identity f
  valueRetrieverNow = valueRetriever iftsi
  changedEntityFields = runIdentity (event valueRetrieverNow)
  in
  iftsi {
    iftsiNow = eventTime,
    iftsiEntityFieldStates = updateEntityFields changedEntityFields (iftsiEntityFieldStates iftsi)
  }




beginningOfTime :: BaseTime -> ExtendedTime
beginningOfTime t = ExtendedTime t 0 0

moveIFTSIToFutureTime :: ExtendedTime -> InefficientFlatTimeStewardInstance -> InefficientFlatTimeStewardInstance
moveIFTSIToFutureTime futureT iftsi
  | futureT >= iftsiNow iftsi =
    case nextEvent iftsi of
      Nothing -> iftsi { iftsiNow = futureT }
      Just (eventTime, event)
        | eventTime > futureT -> iftsi { iftsiNow = futureT }
        | otherwise ->
          let iftsi' = executeEvent eventTime event iftsi
          in moveIFTSIToFutureTime futureT iftsi'
  | otherwise = error "not defined for past times"

